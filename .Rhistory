#########################################################################
### Change working name ###
mat <- gsub(x = gsub(x = mat, '.csv', ''), '-', '_')
### structure = dom.data$matrix[[45]]
dom.data[[mat]]$matrix <- working.mat
dom.data[[mat]]$metadata <- dom.metadata[dom.metadata$fileid == mat,]
### Add other columns from metadata
for(col in names(dom.metadata)){
if(col == 'fileid')
next
dom.data[[col]][length(dom.data[[col]])+1][[1]] <- dom.metadata[dom.metadata$fileid == mat,col]
}
# ### structure = dom.data$fileid$matrix
# ##### Combine matrix and metadata #####
# mat.data <- as.list(metadata[metadata$fileid == mat,])
# mat.data$matrix <- working.mat
#
# ## reorder so that matrix is first
# mat.data <- mat.data[c('matrix', names(metadata))]
#
# ### Save matrix in master list
# dom.data[[mat]] <- mat.data
}
dom.data <- list()
for(mat in matrices){
### Read in matrix, add dimnames, remove diagonals, convert to numeric ###
working.mat <- as.matrix(read.table(paste0('../phylodom/data/',mat),
sep = ',', header = TRUE, row.names = 1))
diag(working.mat) <- NA
class(working.mat) <- 'numeric'
#########################################################################
### Change working name ###
mat <- gsub(x = gsub(x = mat, '.csv', ''), '-', '_')
### structure = dom.data$matrix[[45]]
dom.data[[mat]]$matrix <- working.mat
dom.data[[mat]]$metadata <- dom.metadata[dom.metadata$fileid == mat,]
#
# ### Add other columns from metadata
# for(col in names(dom.metadata)){
#   if(col == 'fileid')
#     next
#   dom.data[[col]][length(dom.data[[col]])+1][[1]] <- dom.metadata[dom.metadata$fileid == mat,col]
# }
# ### structure = dom.data$fileid$matrix
# ##### Combine matrix and metadata #####
# mat.data <- as.list(metadata[metadata$fileid == mat,])
# mat.data$matrix <- working.mat
#
# ## reorder so that matrix is first
# mat.data <- mat.data[c('matrix', names(metadata))]
#
# ### Save matrix in master list
# dom.data[[mat]] <- mat.data
}
dom.data[[3]]
?purr:map
?purr:map
?purr::map
?purrr::map
library(purrr)
View(dom.data)
map(dom.data, "matrix")
map(dom.data, "metadata")
View(map(dom.data, "metadata"))
View(map_dfr(dom.data, "metadata"))
map_df(dom.data, "metadata")['taxon'] == 'Primates'
map_df(dom.data, "metadata")['taxon'] == 'Primate'
dom.data[[map_df(dom.data, "metadata")['taxon'] == 'Primate']]
dom.data[map_df(dom.data, "metadata")['taxon'] == 'Primate']
columns = 'species'
!all(columns) %in% names(dom.data[[1]]$metadata)
!all(columns) %in% names(dom.data[[1]]$metadata)
!all(columns) %in% names(dom.data[[1]]$metadata)
!all(columns) %in% names(dom.data[[1]]$metadata)
dom.data[[1]]$metadata
names(dom.data[[1]]$metadata)
if(!all(columns %in% names(dom.data[[1]]$metadata)))
!all(columns %in% names(dom.data[[1]]$metadata))
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
columns
columns <- list('species', 'turdz')
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
stop('length of \'columns\' must equal length of \'values\'')
dom.data[map_df(dom.data, "metadata")[columns[[i]]] %in% values[[i]]]
i = 1
dom.data[map_df(dom.data, "metadata")[columns[[i]]] %in% values[[i]]]
values = 'Primate'
dom.data[map_df(dom.data, "metadata")[columns[[i]]] %in% values[[i]]]
map_df(dom.data, "metadata")[columns[[i]]] %in% values[[i]]
columns
columns <- list('species', 'captivity')
columns <- list('taxon', 'captivity')
values <- list('Primate', 'Natural')
i = 1
dom.data[map_df(dom.data, "metadata")[columns[[i]]] %in% values[[i]]]
map_df(dom.data, "metadata")
dom.data[map_df(dom.data, "metadata")[columns[[i]]],]
map_df(dom.data, "metadata")[columns[[i]]]
map_df(dom.data, "metadata")[columns[[i]]] %in% values[[i]]]
map_df(dom.data, "metadata")[columns[[i]]] %in% values[[i]]
values[[i]] %in% map_df(dom.data, "metadata")[columns[[i]]]
values[[i]]
map_df(dom.data, "metadata")[columns[[i]]]
map_df(dom.data, "metadata")[columns[[i]]] %in% values[[i]]
map_df(dom.data, "metadata")[columns[[i]]]
map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
map_df(dom.data, "metadata")[[columns[[i]]]]
map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
indices <- TRUE
for(i in columns){
indices <- indices & map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
i
columns
for(i in 1:length(columns)){
indices <- indices & map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
indices
class(columns)
subset_archive <- function(dom.data = dom.data, columns, values){
#-------ERROR CHECKING------#
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop('length of \'columns\' must equal length of \'values\'')
}
#
if(length(columns == 1) & !'list' %in% class(columns))
columns <- list(columns)
if(length(values == 1) & !'list' %in% class(values))
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
}
dom.data[[indices]]
dom.data[indices]
subset_archive <- function(dom.data = dom.data, columns, values){
#-------ERROR CHECKING------#
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop('length of \'columns\' must equal length of \'values\'')
}
#
if(length(columns == 1) & !'list' %in% class(columns))
columns <- list(columns)
if(length(values == 1) & !'list' %in% class(values))
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dom.data[indices])
}
subset_archive(dom.data, columns = 'taxon', values = c('Primate', 'Primates'))
subset_archive(dom.data, columns = 'taxon', values = c('Primate', 'Primates'))
subset_archive(dom.data, columns = list('taxon'), values = list(c('Primate', 'Primates')))
columns = list('taxon')
list(c('Primate', 'Primates'))
#-------ERROR CHECKING------#
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop('length of \'columns\' must equal length of \'values\'')
}
values = list(c('Primate', 'Primates'))
subset_archive(dom.data, columns = list('taxon'), values = list(c('Primate', 'Primates')))
#-------ERROR CHECKING------#
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop('length of \'columns\' must equal length of \'values\'')
}
#
if(length(columns == 1) & !'list' %in% class(columns))
columns <- list(columns)
if(length(values == 1) & !'list' %in% class(values))
length(columns == 1)
columns
columns = list('taxon')
#-------ERROR CHECKING------#
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop('length of \'columns\' must equal length of \'values\'')
}
#
if(length(columns == 1) & !'list' %in% class(columns))
columns <- list(columns)
columns = list('taxon')
length(columns == 1)
length(columns == 1)
length(columns == 1)
length(columns == 1)
length(columns == 1)
length(columns == 1)
length(columns == 1)
length(columns == 1)
subset_archive <- function(dom.data = dom.data, columns, values){
#-------ERROR CHECKING------#
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop('length of \'columns\' must equal length of \'values\'')
}
#
if(length(columns) == 1 & !'list' %in% class(columns))
columns <- list(columns)
if(length(values == 1) & !'list' %in% class(values))
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dom.data[indices])
}
subset_archive(dom.data, columns = list('taxon'), values = list(c('Primate', 'Primates')))
subset_archive <- function(dom.data = dom.data, columns, values){
#-------ERROR CHECKING------#
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop('length of \'columns\' must equal length of \'values\'')
}
#
if(length(columns) == 1 & !'list' %in% class(columns))
columns <- list(columns)
if(length(values) == 1 & !'list' %in% class(values))
values <- list(values)
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dom.data[indices])
}
subset_archive(dom.data, columns = list('taxon'), values = list(c('Primate', 'Primates')))
subset_archive(dom.data, columns = 'taxon', values = list(c('Primate', 'Primates')))
install.packages('tolr')
install.packages('rotl')
vignette(package = 'rotl')
vignette('rotl', package = 'rotl')
stop('length of \'columns\' must equal length of \'values\'')
stop("Must provide either 'fileids' or both 'columns' and 'values' for data subsetting")
metadata <- purrr::map_df(dom.data, 'metadata')
metadata
fileids <- metadata$fileid[1:10]
fileids
md <- purrr::map_df(dom.data, "metadata")
dom.data[which(md$fileid) %in% fileids]
dom.data[which(md$fileid %in% fileids)]
dom.data[[fileids]]
dom.data[fileids]
names(dom.data)
all(fileids %in% names(dom.data))
which(!fileids %in% names(dom.data))
stop("some fileids not in names(dom.data). Mismatches: ", which(!fileids %in% names(dom.data)))
if(is.null(fileids)){
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop("length of 'columns' must equal length of 'values'")
}
#
if(length(columns) == 1 & !'list' %in% class(columns))
columns <- list(columns)
if(length(values) == 1 & !'list' %in% class(values))
values <- list(values)
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dom.data[indices])
}else{
if(!all(fileids %in% names(dom.data))){
stop("some fileids not in names(dom.data). Mismatches: ", which(!fileids %in% names(dom.data)))
}
return(dom.data[fileids])
}
subset_archive <- function(fileids = NULL, dom.data = dom.data, columns = NULL, values = NULL){
#-------ERROR CHECKING------#
if(!is.null(fileids) & (!is.null(columns) | !is.null(values))){
warning("'fileids' provided. Ignoring 'columns' and 'values' arguments")
}
if(is.null(fileids) & (is.null(columns) | is.null(values))){
stop("Must provide either 'fileids' or both 'columns' and 'values' for data subsetting")
}
if(is.null(fileids)){
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop("length of 'columns' must equal length of 'values'")
}
#
if(length(columns) == 1 & !'list' %in% class(columns))
columns <- list(columns)
if(length(values) == 1 & !'list' %in% class(values))
values <- list(values)
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dom.data[indices])
}else{
if(!all(fileids %in% names(dom.data))){
stop("some fileids not in names(dom.data). Mismatches: ", which(!fileids %in% names(dom.data)))
}
return(dom.data[fileids])
}
}
subset_archive(dom.data, columns = 'taxon', values = list(c('Primate', 'Primates')))
subset_archive <- function(dom.data = dom.data, fileids = NULL, columns = NULL, values = NULL){
#-------ERROR CHECKING------#
if(!is.null(fileids) & (!is.null(columns) | !is.null(values))){
warning("'fileids' provided. Ignoring 'columns' and 'values' arguments")
}
if(is.null(fileids) & (is.null(columns) | is.null(values))){
stop("Must provide either 'fileids' or both 'columns' and 'values' for data subsetting")
}
if(is.null(fileids)){
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop("length of 'columns' must equal length of 'values'")
}
#
if(length(columns) == 1 & !'list' %in% class(columns))
columns <- list(columns)
if(length(values) == 1 & !'list' %in% class(values))
values <- list(values)
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dom.data[indices])
}else{
if(!all(fileids %in% names(dom.data))){
stop("some fileids not in names(dom.data). Mismatches: ", which(!fileids %in% names(dom.data)))
}
return(dom.data[fileids])
}
}
subset_archive(dom.data, columns = 'taxon', values = list(c('Primate', 'Primates')))
subset_archive(fileids = c('Zine_2000'))
subset_archive(fileids = c('Zine_2000'))
fileids = c('Zine_2000')
subset_archive(fileids = c('Zine_2000'))
if(!is.null(fileids) & (!is.null(columns) | !is.null(values))){
warning("'fileids' provided. Ignoring 'columns' and 'values' arguments")
}
if(is.null(fileids) & (is.null(columns) | is.null(values))){
stop("Must provide either 'fileids' or both 'columns' and 'values' for data subsetting")
}
if(is.null(fileids)){
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop("length of 'columns' must equal length of 'values'")
}
#
if(length(columns) == 1 & !'list' %in% class(columns))
columns <- list(columns)
if(length(values) == 1 & !'list' %in% class(values))
values <- list(values)
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dom.data[indices])
}else{
if(!all(fileids %in% names(dom.data))){
stop("some fileids not in names(dom.data). Mismatches: ", which(!fileids %in% names(dom.data)))
}
return(dom.data[fileids])
}
subset_archive <- function(dataset = dom.data, fileids = NULL, columns = NULL, values = NULL){
#-------ERROR CHECKING------#
if(!is.null(fileids) & (!is.null(columns) | !is.null(values))){
warning("'fileids' provided. Ignoring 'columns' and 'values' arguments")
}
if(is.null(fileids) & (is.null(columns) | is.null(values))){
stop("Must provide either 'fileids' or both 'columns' and 'values' for data subsetting")
}
if(is.null(fileids)){
if(!all(columns %in% names(dom.data[[1]]$metadata))){
stop(columns[which(!columns %in% names(dom.data[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop("length of 'columns' must equal length of 'values'")
}
#
if(length(columns) == 1 & !'list' %in% class(columns))
columns <- list(columns)
if(length(values) == 1 & !'list' %in% class(values))
values <- list(values)
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dom.data, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dom.data[indices])
}else{
if(!all(fileids %in% names(dom.data))){
stop("some fileids not in names(dom.data). Mismatches: ", which(!fileids %in% names(dom.data)))
}
return(dom.data[fileids])
}
}
subset_archive(dom.data, columns = 'taxon', values = list(c('Primate', 'Primates')))
subset_archive(fileids = c('Zine_2000'))
subset_archive <- function(dataset = dom.data, fileids = NULL, columns = NULL, values = NULL){
#-------ERROR CHECKING------#
if(!is.null(fileids) & (!is.null(columns) | !is.null(values))){
warning("'fileids' provided. Ignoring 'columns' and 'values' arguments")
}
if(is.null(fileids) & (is.null(columns) | is.null(values))){
stop("Must provide either 'fileids' or both 'columns' and 'values' for data subsetting")
}
if(is.null(fileids)){
if(!all(columns %in% names(dataset[[1]]$metadata))){
stop(columns[which(!columns %in% names(dataset[[1]]$metadata))], ' not a column in metadata')
}
if(length(columns) != length(values)){
stop("length of 'columns' must equal length of 'values'")
}
#
if(length(columns) == 1 & !'list' %in% class(columns))
columns <- list(columns)
if(length(values) == 1 & !'list' %in% class(values))
values <- list(values)
indices <- TRUE
for(i in 1:length(columns)){
indices <- indices & purrr::map_df(dataset, "metadata")[[columns[[i]]]] %in% values[[i]]
}
return(dataset[indices])
}else{
if(!all(fileids %in% names(dataset))){
stop("some fileids not in names(dataset). Mismatches: ", which(!fileids %in% names(dataset)))
}
return(dataset[fileids])
}
}
subset_archive(dom.data, columns = 'taxon', values = list(c('Primate', 'Primates')))
subset_archive(fileids = c('Zine_2000'))
dataset[fileids]
dataset <- dom.data
dataset[fileids]
purrr::map_df(dataset, 'matrix')[fileids]
purrr::map_df(dataset, 'matrix')
map(dataset, 'matrix')
purrr::map(dataset, 'matrix')[fileids]
indices
purrr::map(dataset, 'matrix')[indices]
View(dom.data)
dom.data$SchjelderupEbbe_1922a
dom.data$SchjelderupEbbe_1922a$matrix
metadata[metadata$fileid == 'ScjelderupEbbe_1922a$metadata']
metadata[metadata$fileid == 'SchjelderupEbbe_1922a$metadata']
metadata[metadata$fileid == 'SchjelderupEbbe_1922a']
metadata[metadata$fileid == 'SchjelderupEbbe_1922a',]
library(dplyr)
(list = ls())
library(here())
library(httr)
options(stringsAsFactors = FALSE)
matrices <- list.files('../phylodom/data/')
dom.metadata <- read.csv('../phylodom/metadata/matrixdata_metadata.csv')
## Change filenames to remove .csv, hyphen to underscore ##
dom.metadata$fileid <- gsub(x = gsub(x = dom.metadata$fileid, '.csv', ''), '-', '_')
dom.data <- list()
for(mat in matrices){
### Read in matrix, add dimnames, remove diagonals, convert to numeric ###
working.mat <- as.matrix(read.table(paste0('../phylodom/data/',mat),
sep = ',', header = TRUE, row.names = 1))
diag(working.mat) <- NA
class(working.mat) <- 'numeric'
#########################################################################
### Change working name ###
mat <- gsub(x = gsub(x = mat, '.csv', ''), '-', '_')
### structure = dom.data$matrix[[45]]
dom.data[[mat]]$matrix <- working.mat
dom.data[[mat]]$metadata <- dom.metadata[dom.metadata$fileid == mat,]
#
# ### Add other columns from metadata
# for(col in names(dom.metadata)){
#   if(col == 'fileid')
#     next
#   dom.data[[col]][length(dom.data[[col]])+1][[1]] <- dom.metadata[dom.metadata$fileid == mat,col]
# }
# ### structure = dom.data$fileid$matrix
# ##### Combine matrix and metadata #####
# mat.data <- as.list(metadata[metadata$fileid == mat,])
# mat.data$matrix <- working.mat
#
# ## reorder so that matrix is first
# mat.data <- mat.data[c('matrix', names(metadata))]
#
# ### Save matrix in master list
# dom.data[[mat]] <- mat.data
}
